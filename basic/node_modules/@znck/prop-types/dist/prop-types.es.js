/**
 * @znck/prop-types v0.6.3
 * (c) 2019 Rahul Kadyan <hi@znck.me> (https://znck.me)
 * @license MIT
 */
const TYPES = {
  string: String,
  number: Number,
  object: Object,
  boolean: Boolean,
  function: Function,
  symbol: Symbol,
  array: Array
};
const typeValues = () => Object.values(TYPES);
function flat(arr) {
  if (typeof arr.flat === 'function') return arr.flat();
  return Array.prototype.concat.apply([], arr);
}
function runValidation(validator, value) {
  let strict = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  const types = ensureArray(validator.type);
  return (types.length === 0 || types.some(type => isType(type, value, strict || validator.required !== true))) && (typeof validator.validator !== 'function' || validator.validator(value));
}
function isType(type, item) {
  let nullAllowed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  if (nullAllowed && (item === null || item === undefined)) return true;
  if (Array === type && Array.isArray(item)) return true;
  return Object.entries(TYPES).some((_ref) => {
    let key = _ref[0],
        TYPE = _ref[1];
    return TYPE === type && typeof item === key;
  } // eslint-disable-line valid-typeof
  );
}
function ensureOne(items) {
  if (items.length === 0) throw new Error('Atleast one type or value is required');
}
function ensureArray(value) {
  return Array.isArray(value) ? value : value === undefined ? [] : [value];
}

let config = {};

try {
  config = require('vue');
} catch (e) {}

const hasConsole = typeof console !== 'undefined';
const classifyRE = /(?:^|[-_])(\w)/g;

const classify = str => str.replace(classifyRE, c => c.toUpperCase()).replace(/[-_]/g, '');

const warn = (msg, vm) => {
  const trace = vm ? generateComponentTrace(vm) : '';

  if (config.warnHandler) {
    config.warnHandler.call(null, msg, vm, trace);
  } else if (hasConsole && !config.silent) {
    console.warn(`[Vue warn]: ${msg}${trace}`);
  }
};
const error = (msg, vm) => {
  const trace = vm ? generateComponentTrace(vm) : '';

  if (config.errorHandler) {
    config.errorHandler.call(null, msg, vm, trace);
  } else if (hasConsole && !config.silent) {
    console.error(`[Vue error]: ${msg}${trace}`);
  }
};
const tip = (msg, vm) => {
  if (hasConsole && !config.silent) {
    console.warn(`[Vue tip]: ${msg}` + (vm ? generateComponentTrace(vm) : ''));
  }
};
const formatComponentName = (vm, includeFile) => {
  if (vm.$root === vm) {
    return '<Root>';
  }

  const options = typeof vm === 'function' && vm.cid != null ? vm.options : vm._isVue ? vm.$options || vm.constructor.options : vm;
  let name = options.name || options._componentTag;
  const file = options.__file;

  if (!name && file) {
    const match = file.match(/([^/\\]+)\.vue$/);
    name = match && match[1];
  }

  return (name ? `<${classify(name)}>` : `<Anonymous>`) + (file && includeFile !== false ? ` at ${file}` : '');
};

const repeat = (str, n) => {
  let res = '';

  while (n) {
    if (n % 2 === 1) res += str;
    if (n > 1) str += str;
    n >>= 1;
  }

  return res;
};

const generateComponentTrace = vm => {
  if (vm._isVue && vm.$parent) {
    const tree = [];
    let currentRecursiveSequence = 0;

    while (vm) {
      if (tree.length > 0) {
        const last = tree[tree.length - 1];

        if (last.constructor === vm.constructor) {
          currentRecursiveSequence++;
          vm = vm.$parent;
          continue;
        } else if (currentRecursiveSequence > 0) {
          tree[tree.length - 1] = [last, currentRecursiveSequence];
          currentRecursiveSequence = 0;
        }
      }

      tree.push(vm);
      vm = vm.$parent;
    }

    return '\n\nfound in\n\n' + tree.map((vm, i) => `${i === 0 ? '---> ' : repeat(' ', 5 + i * 2)}${Array.isArray(vm) ? `${formatComponentName(vm[0])}... (${vm[1]} recursive calls)` : formatComponentName(vm)}`).join('\n');
  } else {
    return `\n\n(found in ${formatComponentName(vm)})`;
  }
};

/** @type {import('../types/index')} */

class PropTypes {
  /** @private */
  constructor(type) {
    this.type = type;
  }

  get type() {
    return this._type;
  }

  set type(value) {
    this._type = ensureArray(value);
  }

  get isRequired() {
    this.required = true;
    return this;
  }

  value(value) {
    console.warn(`'PropType.[type].value' is deprecated. Use 'PropType.[type].defaultValue' instead.`);
    return this.defaultValue(value);
  }

  defaultValue(value) {
    this.default = value;
    return this;
  }

  description(description) {
    this.description = description;
    return this;
  }

  validate(cb) {
    console.warn(`'PropType.[type].validate' is deprecated. Use 'PropType.[type].customValidator' instead.`);
    return this.customValidator(cb);
  }

  customValidator(cb) {
    var _this = this;

    if (!(typeof cb === 'function')) return this;
    const validator = this.validator;

    this.validator = function () {
      try {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        return (!(typeof validator === 'function') || validator.call(_this, args)) && cb.apply(_this, args);
      } catch (err) {
        return false;
      }
    };

    return this;
  }
  /** @private */


  static create(type) {
    return new PropTypes(type);
  }
  /** @private */


  static clone(prop) {
    const type = this.create(prop.type);
    type.validate(prop.validator);
    return type;
  }

  static get string() {
    const prop = this.create(String);
    prop.__meta__ = {
      custom: 'any'
    };
    return prop;
  }

  static get number() {
    const prop = this.create(Number);
    prop.__meta__ = {
      custom: 'number'
    };
    return prop;
  }

  static get bool() {
    const prop = this.create(Boolean);
    prop.__meta__ = {
      custom: 'bool'
    };
    return prop;
  }

  static get array() {
    const prop = this.create(Array);
    prop.__meta__ = {
      custom: 'array'
    };
    return prop;
  }

  static get object() {
    const prop = this.create(Object);
    prop.__meta__ = {
      custom: 'object'
    };
    return prop;
  }

  static get func() {
    const prop = this.create(Function);
    prop.__meta__ = {
      custom: 'func'
    };
    return prop;
  }

  static get symbol() {
    const prop = this.create(Symbol);
    prop.__meta__ = {
      custom: 'any'
    };
    return prop;
  }

  static get any() {
    const prop = this.create();
    prop.__meta__ = {
      custom: 'any'
    };
    return prop;
  }

  static instanceOf(type) {
    const prop = this.create(type);
    prop.__meta__ = {
      custom: 'instanceOf',
      type
    };
    return prop;
  }

  static oneOf() {
    for (var _len2 = arguments.length, values = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      values[_key2] = arguments[_key2];
    }

    values = flat(values);
    ensureOne(values);
    const types = Array.from(new Set(values.map(value => TYPES[typeof value] || Object)));
    const prop = this.create(types);
    const setOfValues = new Set(values);
    prop.__meta__ = {
      custom: 'oneOf',
      values
    };

    prop.validator = value => {
      return setOfValues.has(value);
    };

    return prop;
  }

  static oneOfType() {
    for (var _len3 = arguments.length, types = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      types[_key3] = arguments[_key3];
    }

    types = flat(types).map(normalizeType);
    ensureOne(types);
    const prop = this.create(flat(types.map(type => ensureArray(type.type))));
    prop.__meta__ = {
      custom: 'oneOfType',
      types
    };

    prop.validator = value => types.some(validator => runValidation(validator, value));

    return prop;
  }

  static arrayOf() {
    return this.collectionOf(Array, Array.from(arguments));
  }

  static objectOf() {
    return this.collectionOf(Object, Array.from(arguments));
  }
  /** @private */


  static collectionOf(type, expected) {
    const prop = this.create(type);
    const types = flat(expected).map(normalizeType);
    prop.__meta__ = {
      custom: 'collection',
      type,
      item: types
    };

    prop.validator = value => (type === Array ? value : Object.values(value)).every(item => types.some(type => runValidation(type, item)));

    return prop;
  }

  static shape(shape) {
    const prop = this.create(Object);
    const shapeType = {};
    Object.entries(shape).forEach((_ref) => {
      let key = _ref[0],
          value = _ref[1];
      shapeType[key] = normalizeType(value);
    });

    prop.validator = value => {
      if (!(value && typeof value === 'object')) return prop.required !== true;
      return Object.entries(shapeType).every((_ref2) => {
        let key = _ref2[0],
            type = _ref2[1];
        return runValidation(type, value[key]);
      });
    };

    return prop;
  }

  static validate(fn) {
    console.warn(`'PropType.validate' is deprecated. Use 'PropType.run' instead.`);
    return this.run(null, fn);
  }

  static run(context, fn) {
    if (arguments.length === 1) {
      fn = context;
      context = null;
    }

    const logger = createLogger(context);

    try {
      return fn(logger);
    } catch (e) {
      logger.error(e.message);
    }
  }

}

function createLogger(context) {
  return {
    error: message => error(message, context),
    tip: message => tip(message, context),
    warn: message => warn(message, context)
  };
}

function normalizeType(type) {
  if (type instanceof PropTypes) return type;
  if (type in TYPES) return PropTypes.create(TYPES[type]);
  if (typeValues().includes(type)) return PropTypes.create(type);
  if (typeof type === 'function') return {
    validator: type,
    type: []
  };
  return type;
}

export default PropTypes;
